# 메서드와 this

## 메서드 만들기
객체 프로퍼티에 할당된 함수를 메서드(method) 라고 한다.

```js
let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("안녕하세요!");
};

user.sayHi(); // 안녕하세요!


// 함수 선언
function sayHi() {
  alert("안녕하세요!");
};

// 선언된 함수를 메서드로 등록
user.sayHi = sayHi;
```

## 메서드 단축 구문
```js
// 아래 두 객체는 동일하게 동작합니다.

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// 단축 구문을 사용하니 더 깔끔해 보이네요.
user = {
  sayHi() { // "sayHi: function()"과 동일합니다.
    alert("Hello");
  }
};
```

## 메서드와 this
```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
    // 'this'는 '현재 객체'를 나타냅니다.
    alert(this.name);
  }
};

user.sayHi(); // John


// this 대신 user를 사용할 수도 있지만
// 이런식으로 작업 될 경우 원치않는 방향으로
// 코드가 흘러갈 수 있다.
let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert( user.name ); // Error: Cannot read property 'name' of null
  }

};

let admin = user;
user = null; // user를 null로 덮어씁니다.

admin.sayHi(); // sayHi()가 엉뚱한 객체를 참고하면서 에러가 발생했습니다.
```

## 자유로운 this
js에서 this는 런타임에 따라 결정됩니다.
메서드가 어디서 정의되었는지에 상관 없이
this는 (.)점 앞의 객체가 무엇인가에 따라 자유롭게 결정됩니다.

```js
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// 별개의 객체에서 동일한 함수를 사용함
user.f = sayHi;
admin.f = sayHi;

// 'this'는 '점(.) 앞의' 객체를 참조하기 때문에
// this 값이 달라짐
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (점과 대괄호는 동일하게 동작함)
```

## 객체 없이 호출하기
```jsx
function sayHi() {
  alert(this);
}

// 엄격모드에서는 undefined
// 엄격모드 아닐 때는 window라는 전역 객체를 참조
sayHi(); 
```

## this가 없는 화살표 함수
화살표 함수는 일반 함수와는 달리 ‘고유한’ this를 가지지 않습니다. 화살표 함수에서 this를 참조하면, 화살표 함수가 아닌 ‘평범한’ 외부 함수에서 this 값을 가져옵니다.
별개의 this가 만들어지는 건 원하지 않고, 외부 컨텍스트에 있는 this를 이용하고 싶은 경우 화살표 함수가 유용합니다.
```js
let user = {
  firstName: "보라",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // 보라
```

## 정리

- 일반 함수: 호출한 주체에 따라 this 달라짐.
- 메서드: 메서드를 소유한 객체.
- 생성자: 새 인스턴스.
- 화살표 함수: 외부 스코프의 this.




