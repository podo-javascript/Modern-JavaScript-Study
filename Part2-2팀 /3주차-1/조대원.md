# 배열과 메서드

## splice
배열에서 요소를 하나만 지우거나, 추가할 때 사용

```js
// 1번째 부터 1개 삭제
let arr = ["I", "study", "JavaScript"];
arr.splice(1, 1);
alert( arr ); // ["I", "JavaScript"]

// 처음(0) 세 개(3)의 요소를 지우고, 이 자리를 다른 요소로 대체합니다.
let arr = ["I", "study", "JavaScript", "right", "now"];
arr.splice(0, 3, "Let's", "dance");
alert( arr ) // now ["Let's", "dance", "right", "now"]


// 인덱스 2부터
// 0개의 요소를 삭제합니다.
// 그 후, "complex"와 "language"를 추가합니다.
let arr = ["I", "study", "JavaScript"];
arr.splice(2, 0, "complex", "language");
alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

## slice
```js
// 이 메서드는 "start" 인덱스부터 ("end"를 제외한) "end"인덱스까지의 요소를 복사한 새로운 배열을 반환합니다.
// start와 end는 둘 다 음수일 수 있는데 이땐, 배열 끝에서부터의 요소 개수를 의미합니다.
arr.slice([start], [end])

let arr = ["t", "e", "s", "t"];

// e,s (인덱스가 1인 요소부터 인덱스가 3인 요소까지를 복사(인덱스가 3인 요소는 제외))
alert( arr.slice(1, 3) ); 
// s,t (인덱스가 -2인 요소부터 제일 끝 요소까지를 복사)
alert( arr.slice(-2) );
// 인수를 넣지 않으면 그대로 복사
alert( arr.slice() );
```

## concat
```js
// 기존 배열의 요소를 사용해 새로운 배열을 만들거나
// 기존 배열에 요소를 추가하고자 할 때 사용할 수 있습니다.
arr.concat(arg1, arg2...)

// 예시
let arr = [1, 2];

// arr의 요소 모두와 [3,4]의 요소 모두를 한데 모은 새로운 배열이 만들어집니다.
alert( arr.concat([3, 4]) ); // 1,2,3,4

// arr의 요소 모두와 [3,4]의 요소 모두, [5,6]의 요소 모두를 모은 새로운 배열이 만들어집니다.
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// arr의 요소 모두와 [3,4]의 요소 모두, 5와 6을 한데 모은 새로운 배열이 만들어집니다.
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

## forEach
```js
// 주어진 함수를 배열 요소 각각에 대해 실행할 수 있게 해줍니다.
arr.forEach(function(item, index, array) {
  // 요소에 무언가를 할 수 있습니다.
});

["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
 // array 는 배열 전체가 출력됨
  alert(`${item} is at index ${index} in ${array}`);
});
```

## 배열 탐색하기

## indexOf, lastIndexOf와 includes
같은 이름을 가진 문자열 메서드와 문법이 동일합니다. 
물론 하는 일도 같습니다. 
연산 대상이 문자열이 아닌 배열의 요소라는 점만 다릅니다.

```js

// arr.indexOf(item, from)는 인덱스 from부터 시작해 item(요소)을 찾습니다.
// 요소를 발견하면 해당 요소의 인덱스를 반환하고, 발견하지 못했으면 -1을 반환합니다.

// arr.lastIndexOf(item, from)는 위 메서드와 동일한 기능을 하는데,
// 검색을 끝에서부터 시작한다는 점만 다릅니다.

// arr.includes(item, from)는 인덱스 from부터 시작해 item이 있는지를 검색하는데,
// 해당하는 요소를 발견하면 true를 반환합니다.

let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```


## find와 findIndex
```js
특정 조건에 부합하는 객체를 배열 내에서 찾기
let result = arr.find(function(item, index, array) {
  // true가 반환되면 반복이 멈추고 해당 요소를 반환합니다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환합니다.

  // item - 함수를 호출할 요소
  // index – 요소의 인덱스
  // array – 배열 자기 자신
});

let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John

// findIndex는 find와 동일한 일을 하나,
// 조건에 맞는 요소를 반환하는 대신 해당 요소의 인덱스를 반환한다는 점이 다릅니다.
// 조건에 맞는 요소가 없으면 -1이 반환됩니다.
```

## filter
```js
// find 메서드는 함수의 반환 값을 true로 만드는 단 하나의 요소를 찾습니다.
// filter는 find와 문법이 유사하지만, 조건에 맞는 요소 전체를 담은 배열을 반환한다는 점에서 차이가 있습니다.

let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소는 results에 순차적으로 더해집니다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열이 반환됩니다.
});

let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 앞쪽 사용자 두 명을 반환합니다.
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

## 배열을 변형하는 메서드

## map
```js
// 배열 요소 전체를 대상으로 함수를 호출하고, 함수 호출 결과를 배열로 반환해줍니다.
let result = arr.map(function(item, index, array) {
  // 요소 대신 새로운 값을 반환합니다.
});

// 예시
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

## sort
```js
// 배열의 요소를 정렬해줍니다.
// 배열 자체가 변경됩니다.
// sort에 정렬 함수를 인수로 넘겨주지 않으면 이
// 메서드는 사전편집 순으로 요소를 정렬합니다.

let arr = [ 1, 2, 15 ];

// arr 내부가 재 정렬됩니다.
arr.sort();

// 요소는 문자열로 취급되어 재 정렬되기 때문에
// 정렬이 되지 않음
alert( arr );  // 1, 15, 2

// 오름차순 정리 (숫자 시)
function compareNumeric(a, b) {
  // 첫 번째 값이 두 번째 값보다 큰 경우
  if (a > b) return 1;
  // 두 값이 같은 경우
  if (a == b) return 0;
  //  첫 번째 값이 두 번째 값보다 작은 경우
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15

// 간단하게 사용 가능
arr.sort( (a, b) => a - b );

// 문자열에는 localeCompare 사용
let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (제대로 정렬이 되지 않았습니다.)
alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (제대로 정렬되었네요!)
```

## split과 join
```js
// split, 쉼표 단위로 구분
let names = 'Bilbo, Gandalf, Nazgul';
let arr = names.split(', ');
for (let name of arr) {
  alert( `${name}에게 보내는 메시지` ); // Bilbo에게 보내는 메시지
}

// 배열의 길이를 제한 할 수 있다.
// 배열 2개까지
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);
alert(arr); // Bilbo, Gandalf

// 빈문자열을 지정하면 문자열을 글자 단위로 분리할 수 있다.
let str = "test";

alert( str.split('') ); // t,e,s,t

// join, 인수glue를 접착제처럼  사용해 배열 요소를 모두 합친 후 하나의 문자열을 만들어줍니다.
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // 배열 요소 모두를 ;를 사용해 하나의 문자열로 합칩니다.

alert( str ); // Bilbo;Gandalf;Nazgul
```

## reduce와 redeceRight
```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);

// accumulator – 이전 함수 호출의 결과. initial은 함수 최초 호출 시 사용되는 초깃값을 나타냄(옵션)
// item – 현재 배열 요소
// index – 요소의 위치
// array – 배열

// 예
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15

// reduceRight는 reduce와 동일한 기능을 하지만
// 배열의 오른쪽부터 연산을 수행한다는 점이 다른 메서드입니다.
```

## isArray
```js
// 배열인지 아닌지 확인할때 사용합니다.
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

## thisArg
```js
// 함수를 호출하는 대부분의 배열 메서드(find, filter, map 등. sort는 제외)는
// thisArg라는 매개변수를 옵션으로 받을 수 있습니다.
// thisArg는 func의 this가 됩니다.
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// army.canJoin 호출 시 참을 반환해주는 user를 찾음
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23

// thisArgs에 army를 지정하지 않고 단순히
// users.filter(army.canJoin)를 사용했다면 army.canJoin은 단독 함수처럼 취급되고,
// 함수 본문 내 this는 undefined가 되어 에러가 발생했을 겁니다.

// users.filter(user => army.canJoin(user))를 사용하면
// users.filter(army.canJoin, army)를 대체할 수 있긴 한데
// thisArg를 사용하는 방식이 좀 더 이해하기 쉬우므로 더 자주 사용됩니다.
```

## some
```js
// 배열 안의 어떤 요소라도 주어진 판별 함수를 적어도 하나라도 통과하는지 테스트합니다.
// 만약 배열에서 주어진 함수가 true을 반환하면 true를 반환합니다.
const array = [1, 2, 3, 4, 5];

const even = (element) => element % 2 === 0;

console.log(array.some(even));
```

## every
```js
//메서드는 배열의 모든 요소가 제공된 함수로 구현된 테스트를 통과하는지 테스트합니다. 이 메서드는 불리언 값을 반환합니다.
const isBelowThreshold = (currentValue) => currentValue < 40;

const array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
```

## fill
```js
// 배열의 인덱스 범위 내에 있는 모든 요소를 정적 값으로 변경합니다.
// 그리고 수정된 배열을 반환합니다.
const array1 = [1, 2, 3, 4];

// [1, 2, 0, 0]
console.log(array1.fill(0, 2, 4));

// [1, 5, 5, 5]
console.log(array1.fill(5, 1));

// [6, 6, 6, 6]
console.log(array1.fill(6));
```

## copyWithin
```js
// 배열의 일부를 같은 배열의 다른 위치로 얕게 복사하며,
// 배열의 길이를 수정하지 않고 해당 배열을 반환합니다.

const array1 = ["a", "b", "c", "d", "e"];

// ["d", "b", "c", "d", "e"]
console.log(array1.copyWithin(0, 3, 4));

// ["d", "d", "e", "d", "e"]
console.log(array1.copyWithin(1, 3));
```



